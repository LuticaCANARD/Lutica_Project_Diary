> 출처 : [레디스에서의 분산 락](https://redis.io/docs/manual/patterns/distributed-locks/)

## Safety and Liveness Guarantees
> 안전성 및 생명 주기 보장
- 우리는 분산 락을 사용하는데 있어서 효과적인 방법으로 사용하는데 있어 필요한 최조한의 보장인 세 가지 속성으로 모델을 만들어보겠습니다.
1. 안전성 속성 : 상호(Mutual) 배제. 어떤 순간에서, **단 하나의 클라이언트 만이 락(Lock)을 획득 가능합니다.**
2. 생명 주기 속성 A: Deadlock에서 자유로워야 합니다. 결국, 리소스가 잠근 클라이언트가 충돌 혹은 나누어 지더라도  **항상 Lock을 획득합니다.**
3. 생명 주기 속성 B: 실패 관용.  대부분의 Redis node가 켜져있는 한, 클라이언트를 Lock을 **얻고 풀 수 있어야 합니다.**

## Why Failover-based Implementations Are Not Enough
> 왜 Failover(1) 구현으로는 충분하지 않은가.
> 1) fail한 다음의 구현이 있는 형식

- 우리가 무엇을 개선 하려는 지 알기 이전에, 대부분의 Redis기반의 분산 락 라이브러리의 현 상태를 분석해 봅시다.
- 가장 간단하게 Redis를 자원 Lock으로 사용하는 방법은, 인스턴스 내의 키로 만드는 것입니다. Key는 일반적으로 Redis의 만료 시간 기능을 활용해 **유한한 시간**동안 생존하며, 그러므로 결국은 **해제됩니다.** (속성 중 2번 참조.) 클라이언트가 리소스를 해제할 필요가 있는 경우, 키를 삭제합니다.


## The Redlock Algorithm
> Redlock 알고리즘
> 

- 알고리즘의 분산 버전에서는 N개의 Redis 마스터가 있다고 가정합니다. 
- 이러한 노드는 완전히 독립적이므로 복제나 기타 암시적 조정 시스템을 사용하지 않습니다. 단일 인스턴스에서 안전하게 잠금을 획득하고 해제하는 방법은 이미 설명했습니다. 
- 우리는 알고리즘이 이 방법을 사용하여 단일 인스턴스에서 잠금을 획득하고 해제하는 것을 당연하게 여깁니다. 
- 예제에서는 합리적인 값인 N=5를 설정하므로 대부분 독립적인 방식으로 실패하도록 보장하기 위해 서로 다른 컴퓨터 또는 가상 머신에서 5개의 Redis 마스터를 실행해야 합니다.

- 잠금을 획득하기 위해 클라이언트는 다음 작업을 수행합니다.

1. 현재 시간을 밀리 초 단위로 가져옵니다.
2. 모든 인스턴스에서 동일한 키 이름과 임의의 값을 사용하여 모든 N 인스턴스에서 순차적으로 잠금을 획득하려고 시도합니다.
> 2단계에서 각 인스턴스에 잠금을 설정할 때 클라이언트는 잠금을 획득하기 위해 총 잠금 자동 해제 시간에 비해 작은 제한 시간을 사용합니다. 
> 예를 들어 자동 해제 시간이 10초인 경우 제한 시간은 ~ 5~50밀리초 범위일 수 있습니다. 
> 이렇게 하면 클라이언트가 다운된 Redis 노드와 통신하려고 오랫동안 차단되는 것을 방지할 수 있습니다.
> 인스턴스를 사용할 수 없는 경우 최대한 빨리 다음 인스턴스와 통신을 시도해야 합니다.
3. 클라이언트는 1단계에서 얻은 타임스탬프를 현재 시간에서 빼서 잠금을 획득하는 데 경과된 시간을 계산합니다. 
> ⚠️ 클라이언트가 대부분의 인스턴스(최소 3개)에서 잠금을 획득할 수 있었던 경우에만 해당됩니다.  
> ❗잠금을 획득하는데 소요된 총 시간이 잠금 유효 시간보다 작을 경우 잠금을 획득한 것으로 간주됩니다.
4. 잠금이 획득된 경우 유효 시간은 3단계에서 계산된 대로 초기 유효 시간에서 경과 시간을 뺀 것으로 간주됩니다.
5. 클라이언트가 어떤 이유로 잠금 획득에 실패한 경우(N/2+1 인스턴스를 잠글 수 없거나 유효 시간이 음수인 경우) 모든 인스턴스의 잠금을 해제하려고 시도합니다 (그렇지 않다고 생각되는 인스턴스도 포함)

## Is the Algorithm Asynchronous?
> 알고리즘은 비동기식인가요?
